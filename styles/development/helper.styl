.hidden
[hidden]
  display: none !important

// @note container-name "grid" définit dans grid.styl.

@container grid (width < 35.01em)

  .xs-hidden
    display: none !important

@container grid (35.01em < width < 50.01em)

  .s-hidden
    display: none !important

@container grid (50.01em < width < 70.01em)

  .m-hidden
    display: none !important

@container grid (70.01em < width < 92.01em)

  .l-hidden
    display: none !important

.invisible // @note Cacher l'élément en laissant son emplacement @affected Lecteurs d'écran inclus
  visibility: hidden

a[aria-disabled=true] // @tod En expérimentation.
  cursor: not-allowed
  &:active
    pointer-events: none

// @note Caché visuellement mais disponible pour les lecteurs d'écran.
// @see https://github.com/h5bp/html5-boilerplate/blob/master/dist/css/style.css

.sr-only
  position: absolute
  transform: scale(0) // @note Plus propre à l'inspection des éléments que `clip-path: inset(50%)`

/*
.sr-only
  position: absolute
  overflow: hidden
  width: 1px
  height: 1px
  margin: -1px
  padding: 0
  white-space: nowrap
  border: 0
  clip-path: rect(0, 0, 0, 0)
*/

//.relative // @note Classe habituellement ajoutée en js sur des éléments parents
//  position: relative

.protected // @note Protège partiellement le texte en empêchant sa sélection
  user-select: none

.onaline // @note Texte sur une ligne sans dépassement
  overflow: hidden
  white-space: nowrap
  text-overflow: ellipsis

.balance
  text-wrap: balance

.center
  display: grid
  place-items: center
  // @note Ancienne solution :
  //align-items: center
  //justify-content: center
  // @note Alternative :
  //& > *
  //  place-self: center // @support @see https://caniuse.com/?search=place-self

@container grid (35em > width)
  span.br // @note un 'br' volontairement non sémantique à destination des petites définitions d'écran, à placer sur un span englobant un espace
    display: block

@container grid (35em > width)
  .xs-center
    display: grid
    place-items: center

//.center-x // @todo
//.center-y // @todo

//.push
//  margin-left: auto

//[class*=rotate]
//  transform-origin: 50% 50%

for _i in 90 180 // 45 135
  .rotate{_i}
    transform: rotate(_i * 1deg)

// @note .zoom permet de jouer sur la taille des éléments enfants codés en unité relative
// - cette technique est incompatible avec les unités les éléments utilisant vmin
// - pas de possibilité de zoom avec cette technique au-dessous de 50%
// - pas de '.scale100' : aucun intérêt...
.reverse
  transform: scaleX(-1)

.size
  --size: 25em
  --size-width: var(--size)
  --size-height: var(--size)
  width: var(--size-width)
  height: var(--size-height)
  max-width: 100%
  max-height: 100vh

.vw80
  --size: 25em
  --size-width: var(--size)
  width: calc(var(--size) * .8)

//.scale
//  font-size: var(--scale, 100%)

for _i in 300 250 200 175 160 150 140 130 120 115 110 105 95 90 85 80 75 70 60 50 40 30
  .scale{_i}
    font-size: _i * 1%

.rescale
  font-size: 1rem // @note Réinitialisation d'un élément enfant si élément parent zoomé, valeur égale à la taille d'origine

@container grid (35em > width)
  .xs-scale
    font-size: var(--xs-scale, 80%)

.blink
  animation: anim-blink 1.2s infinite
  //animation: anim-blink 1s steps(2, start) infinite

@keyframes anim-blink
  50%
    display: none
    filter: invert(1)

.no-overscroll
  overscroll-behavior-x: none // @note Empèche la navigation par swipe sur mobile.

.no-print .cmd-print // @see Firefox Android a perdu sa fonction d'impression...
  display: none

/* @see https://css-tricks.com/how-to-play-and-pause-css-animations-with-css-custom-properties/
[data-animation]
  animation: var(--anim-name, none) var(--anim-duration, 1s) var(--anim-timinig-function, linear) var(--anim-delay, 0s) var(--anim-iteration-count, infinite) var(--anim-direction, alternate) var(--anim-fill-mode, none) var(--anim-play-state, running)
*/

/*
#progress-page
  position: fixed
  top: 0
  left: 0
  z-index: 9999
  width: 0
  height: .5em
  background-color: _color2
*/
