// @note Avec `minmax` la grille ne sera pas tributaire de son contenu en responsive @see https://css-tricks.com/equal-width-columns-in-css-grid-are-kinda-weird/

:has(> [class^=grid])
.parent-grid // fallback JS
  container: grid / inline-size

[class^=grid]
  display: grid
  grid-auto-flow: dense
  grid-template-columns: repeat(var(--n, 1), minmax(0, 1fr))
  &.row-defines // @note Permet aux spans de la propriété grid-row de se caler sur les lignes. Intéressant mais pas souhaitable d'emblée en production.
    grid-auto-rows: minmax(0, 1fr)
  &.gap
    gap: _gap
  &.gap-bottom
    padding-bottom: _gap // @note padding et non margin, car ne doit pas pouvoir fusionner avec les marges de l'élément suivant.
  &.vertical-gap
    gap: 0 _gap

@container grid (35em < width)

  .grid2
  .grid3
  .grid4
    --n: 2

  .c2
  .c3
  .c4
    grid-column: span 2

@container grid (50em < width)

  .grid3
  .grid4
    --n: 3

  .c3
  .c4
    grid-column: span 3

@container grid (70em < width)

  .grid4
    --n: 4

  .c4
    grid-column: span 4

[class^=grid] .grid2 // @note Si éléments de grille imbriqués @todo En test ; espace de nom pour éviter les effets de bord peut-être inutile.
  --n: 2
  @container grid (25em > width)
    & > *
      grid-column: span 2

.r2
  grid-row: span 2

.r3
  grid-row: span 3

.r4
  grid-row: span 4

@container grid (35em < width)

  .xs-grid2
    --n: 2

@container grid (35em < width < 50em)

  :root .s-grid1
    --n: 1

  :root .s-grid2
    --n: 2

@container grid (50em < width < 70em)

  :root .m-grid1
    --n: 1

  :root .m-grid2
    --n: 2

  :root .m-grid3
    --n: 3

  :root .m-grid4
    --n: 4

@container grid (70em < width < 92em)

  :root .l-grid1
    --n: 1

  :root .l-grid2
    --n: 2

  :root .l-grid3
    --n: 3

  :root .l-grid4
    --n: 4

@container grid (92em < width)

  :root .xl-grid2
    --n: 2
/*
  :root .xl-grid3
    --n: 3

  :root .xl-grid4
    --n: 4
*/

/*
@media (min-width: _sizeXS)

  .grid2
  .grid3
  .grid4
    --n: 2

  .grid5
    --n: 3

@media (min-width: _sizeS)

  .grid3
  .grid4
    --n: 3

  .grid5
    --n: 4

@media (min-width: _sizeL)

  .grid4
    --n: 4

  .grid5
    --n: 5

@media (max-width: _sizeXS)

  .xs-grid2
    --n: 2

@media (min-width: _sizeXS) and (max-width: _sizeS)

  :root .s-grid1
    --n: 1

  :root .s-grid2
    --n: 2

@media (min-width: _sizeS) and (max-width: _sizeL)

  :root .l-grid1
    --n: 1

  :root .l-grid2
    --n: 2

@media (min-width: _sizeL) and (max-width: _sizeXL)

  :root .xl-grid2
    --n: 2
*/

.flex // @todo En test...
  display: flex
  flex-wrap: wrap
  //justify-content space-between
  &.gap
    gap: _gap
  &.gap-bottom
    margin-bottom: _gap
  /* @todo
   * @see https://github.com/w3c/csswg-drafts/issues/3559#issuecomment-557711824
  @supports(gap: 1em)
    & > * + *
      float: left
      margin-left: 1em
  */

/*
// @note Mémento de nos (presques) équivalences grid/flex codées ultérieurement :

// with Grid layout:

.summary
  display: grid
  gap: _gap

@media (min-width: _sizeXS)

  .summary
    grid-template-columns: repeat(2, 1fr)

@media (min-width: _sizeS)

  .summary
    grid-template-columns: repeat(3, 1fr)

@media (min-width: _sizeL)

  .summary
    grid-template-columns: repeat(4, 1fr)

// with flexbox:

.summary
  display: flex
  flex-wrap: wrap
  gap: _gap

.summary > *
  flex: 1 0 100% // = [flex-grow flex-shrink flex-basis]

@media (min-width: _sizeXS)

  .summary > *
    flex-basis: 'calc(50% - %s)' % _gap

@media (min-width: _sizeS)

  .summary > *
    flex-basis: 'calc(33% - %s)' % _gap

@media (min-width: _sizeL)

  .summary > *
    flex-basis: 'calc(25% - %s)' % _gap
*/
