_checkboxColor1 = _colorG - 20%
_checkboxColor2 = _colorG - 30%
_checkboxColor3 = _color2
_checkboxColor5 = _color5
_checkboxSize = 1.2em
_checkboxSize2 = 2px // @note Valeur en lien avec 'transform scale' sur le (pseudo-)élément.

_switchColor1 = rgba(255, 255, 255, .1)
_switchColor2 = _colorG - 20%
_switchColor3 = _color2
_switchColor5 = _color5
_switchSize = 2.5em
_switchSize2 = 3px
_switchBorder = .3em

input[type=checkbox]:not([role=switch])
input[type=radio]:not([role=switch])
  //all: unset
  appearance: none
  display: inline-grid
  width: _checkboxSize
  height: _checkboxSize
  vertical-align: text-top
  box-sizing: border-box
  background-color: _checkboxColor2
  border: .15em solid _colorG
  outline: none
  box-shadow: inset 0 .1em .3em rgba(0, 0, 0, .3)
  cursor: pointer
  &:disabled
    background: _checkboxColor1 repeating-linear-gradient(-45deg, transparent 0 _checkboxSize2, #555 _checkboxSize2 _checkboxSize2 * 2)
    cursor: default
    & + label
      //color: _colorG + 30%
      cursor: default
  &::before
    content: ''
    display: block
    background-color: _checkboxColor3
    transform: scale(0)
  &:focus-visible
    border-color: _checkboxColor5 !important // @note "!important" est nécessaire pour les boutons radio, sinon le focus ne surclasse pas la bordure définie plus haut.

input[type=checkbox]:not([role=switch])
  &::before
    clip-path: polygon(12% 41%, 4% 50%, 38% 84%, 95% 26%, 87% 17%, 37% 67%)
    transition: transform .2s
  &:checked::before
    transform: scale(1.5)

input[type=radio]:not([role=switch])
  border-radius: 50%
  &::before
    clip-path: circle(30% at 50% 50%)
    transition: transform .3s
  &:checked::before
    transform: scale(1)
  &:checked
    border-color: _checkboxColor3

input[role=switch]
  all: unset
  //appearance: none
  vertical-align: middle // @todo À évaluer, dans un contexte géré par les éléments parents...
  box-sizing: border-box
  width: _switchSize * 2
  height: _switchSize
  background-color: _colorG - 30%
  border: _switchBorder solid transparent // _colorG
  border-radius: (_switchSize / 2)
  box-shadow: inset 0 .2em .5em rgba(0, 0, 0, .2)
  cursor: pointer
  &::before
    content: attr(data-a)
    display: block
    width: _switchSize
    height: _switchSize
    text-align: center
    line-height: _switchSize
    color: _colorT
    background-color: _color6
    border-radius: (_switchSize / 2)
    box-shadow: 0 .2em .5em rgba(0, 0, 0, .3)
    transform: translate(- _switchBorder, - _switchBorder)
    transition: transform .2s ease-in-out
  &:checked::before
    content: attr(data-b)
    background-color: _color2
    transform: translate(_switchSize - _switchBorder, - _switchBorder)
  &:disabled
    background-image: repeating-linear-gradient(-45deg, _switchColor1 0 _switchSize2, _switchColor2 0, transparent 0, transparent _switchSize2 * 2)
    cursor: default
    &::before
      color: _colorG + 20%
      background-color: _colorG
    & + label
      //color: _colorG + 30%
      cursor: default
  &:not(:checked)
    & + label
      color: _colorG + 30%
  &:focus-visible
    border-color: _checkboxColor5 !important // @note "!important" est nécessaire pour les boutons radio, sinon le focus ne surclasse pas la bordure définie plus haut.

// @note Le design d'un switch accessible à l'aide des seuls pseudo-éléments est tout à fait possible, mais cette solution rend la modularité du style délicate. Le label n'étant pas indépendant du switch, son positionnement sera limité, des pseudo-éléments utilisants déjà background-image ne peuvent plus être texturés, l'effets "zoom" via font-size sera problématique.

.switch-custom
  position: relative
  width: (_switchSize * 2)
  height: _switchSize
  & [role=switch]
    position: absolute
    inset: 0
    &::before
      display: none
    & + div
      position: absolute
      left: 0
      width: _switchSize
      height: _switchSize
      text-align: center
      line-height: _switchSize
      color: _colorT
      background-color: _color6
      border-radius: (_switchSize / 2)
      box-shadow: 0 .2em .5em rgba(0, 0, 0, .3)
      transition: transform .2s ease-in-out
      pointer-events: none
    &:checked + div
      background-color: _color2
      transform: translate(_switchSize, 0)
    &:disabled + div
      color: _colorG + 20%
      background-color: _colorG
  & [role=switch]:not(:disabled).dual-state + div
      background-color: _color2
  & :not(:checked) + div svg:nth-child(1) // @note `:first-child` et `:last-child` ne fonctionnent pas dans ce cas car un seul svg peut être présent au lieu de deux.
    display: none
  & :checked + div
    transform: translateX(round(_switchSize / 2, 2))
    & svg:nth-child(2) // @note Idem
      display: none
  &:has([role=switch]:not(:checked, .dual-state)) + label
    color: _colorG + 30%
  &:has(:disabled) + label
    //color: _colorG + 30%
    cursor: default
