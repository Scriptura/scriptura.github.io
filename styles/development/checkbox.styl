_checkboxColor1 = _colorG - 20%
_checkboxColor2 = _colorG - 30%
_checkboxColor3 = _color2
_checkboxColor5 = _color5
_checkboxSize = 1.2em
_checkboxSize2 = 2px // @note Valeur en lien avec 'transform scale' sur le (pseudo-)élément.

_switchColor1 = rgba(255, 255, 255, .1)
_switchColor2 = _colorG - 20%
_switchColor3 = _color2
_switchColor5 = _color5
_switchSize = 2.5em
_switchSize2 = 3px
_switchBorder = .3em

input[type=checkbox]:not([role=switch])
input[type=radio]:not([role=switch])
  //all: unset
  appearance: none
  display: inline-grid
  width: _checkboxSize
  height: _checkboxSize
  vertical-align: text-top
  box-sizing: border-box
  background-color: _checkboxColor2
  border: .15em solid _colorG
  outline: none
  box-shadow: inset 0 .1em .3em rgba(0, 0, 0, .3)
  cursor: pointer
  &:disabled
    background: _checkboxColor1 repeating-linear-gradient(-45deg, transparent 0 _checkboxSize2, #555 _checkboxSize2 _checkboxSize2 * 2)
    cursor: default
    & + label
      color: _colorG + 30%
      cursor: default
  &::before
    content: ''
    display: block
    background-color: _checkboxColor3
    transform: scale(0)
  &:focus-visible
    border-color: _checkboxColor5 !important // @note "!important" est nécessaire pour les boutons radio, sinon le focus ne surclasse pas la bordure définie plus haut.

input[type=checkbox]:not([role=switch])
  &::before
    clip-path: polygon(12% 41%, 4% 50%, 38% 84%, 95% 26%, 87% 17%, 37% 67%)
    transition: transform .2s
  &:checked::before
    transform: scale(1.5)

input[type=radio]:not([role=switch])
  border-radius: 50%
  &::before
    clip-path: circle(30% at 50% 50%)
    transition: transform .3s
  &:checked::before
    transform: scale(1)
  &:checked
    border-color: _checkboxColor3

input[role=switch]
  all: unset
  //appearance: none
  vertical-align: middle // @todo À évaluer, dans un contexte géré par les éléments parents...
  box-sizing: border-box
  width: _switchSize * 2
  height: _switchSize
  background-color: _colorG - 30%
  border: _switchBorder solid transparent // _colorG
  border-radius: (_switchSize / 2)
  box-shadow: inset 0 .2em .5em rgba(0, 0, 0, .2)
  cursor: pointer
  &::before
    content: attr(data-a)
    display: block
    width: _switchSize
    height: _switchSize
    text-align: center
    line-height: _switchSize
    color: _colorT
    background-color: _color6
    border-radius: (_switchSize / 2)
    box-shadow: 0 .2em .5em rgba(0, 0, 0, .3)
    transform: translate(- _switchBorder, - _switchBorder)
    transition: transform .2s ease-in-out
  &:checked::before
    content: attr(data-b)
    background-color: _color2
    transform: translate(_switchSize - _switchBorder, - _switchBorder)
  &:disabled
    background-image: repeating-linear-gradient(-45deg, _switchColor1 0 _switchSize2, _switchColor2 0, transparent 0, transparent _switchSize2 * 2)
    cursor: default
    &::before
      color: _colorG + 20%
      background-color: _colorG
    & + label
      color: _colorG + 30%
      cursor: default
  &:not(:checked)
    & + label
      color: _colorG + 30%
  &:focus-visible
    border-color: _checkboxColor5 !important // @note "!important" est nécessaire pour les boutons radio, sinon le focus ne surclasse pas la bordure définie plus haut.

// @note Le design d'un switch accessible à l'aide des seuls pseudo-éléments est tout à fait possible, mais cette solution rend la modularité du style délicate. Le label n'étant pas indépendant du switch, son positionnement sera limité, des pseudo-éléments utilisants déjà background-image ne peuvent plus être texturés, l'effets "zoom" via font-size sera problématique.

.switch-custom
  position: relative
  width: (_switchSize * 2)
  height: _switchSize
  & input[role=switch]
    position: absolute
    inset: 0
    &::before
      display: none
    & + div
      position: absolute
      left: 0
      width: _switchSize
      height: _switchSize
      text-align: center
      line-height: _switchSize
      color: _colorT
      background-color: _color6
      border-radius: (_switchSize / 2)
      box-shadow: 0 .2em .5em rgba(0, 0, 0, .3)
      transition: transform .2s ease-in-out
      pointer-events: none
    &:checked + div
      background-color: _color2
      transform: translate(_switchSize, 0)
  & :not(:checked) + div svg:nth-child(1)
    display: none
  & :checked + div
    transform: translateX(round(_switchSize / 2, 2))
    & svg:nth-child(2)
      display: none

input[role=switch]:checked:has(> .switch-custom) label
  color: orange !important

.switch-svg
  all: unset
  //appearance: none
  display: flex
  align-items: center
  gap: 1em
  & input
    position: absolute
    transform: scale(0)
    &:focus-visible + .switch-bg
      border-color: _checkboxColor5
  & .switch-bg
    flex-shrink: 0
    display: flex
    align-items: center
    justify-content: center
    width: _switchSize * 2
    height: _switchSize
    background-color: _colorG - 30%
    border: .1em solid transparent
    border-radius: _switchSize
    box-shadow: inset 0 .2em .5em rgba(0, 0, 0, .2)
  & .switch-toogle
    position: relative
    z-index: 1
    flex-shrink: 0
    display: flex
    align-items: center
    justify-content: center
    width: _switchSize
    height: _switchSize
    background-color: _color2
    border-radius: 50%
    box-shadow: 0 .2em .5em rgba(0, 0, 0, .3)
    transform: translateX(- round(_switchSize / 2, 2))
    transition: transform .2s ease-in-out
    & svg
     flex-shrink: 0
     display: block
     margin: auto
     width: round(_switchSize / 2, 2)
     height: round(_switchSize / 2, 2)
     fill: curentcolor
  & :not(:checked) + .switch-bg .switch-toogle svg:nth-child(1)
    display: none
  & :checked + .switch-bg .switch-toogle
    transform: translateX(round(_switchSize / 2, 2))
    & svg:nth-child(2)
      display: none
  & :disabled
    & ~ *
      color: _colorG + 20%
      cursor: not-allowed
    & + .switch-bg
      background-image: repeating-linear-gradient(-45deg, _switchColor1 0 _switchSize2, _switchColor2 0, transparent 0, transparent _switchSize2 * 2)
    & + .switch-bg .switch-toogle
      background-color: _colorG
  //&[type=radio]:checked ~ *
  //  cursor: not-allowed

:not(.switch-dual-state) > .switch-svg input:not(:checked):not(:disabled)
  & ~ :last-child
    color: _colorG + 30%
  & + .switch-bg .switch-toogle
    background-color: _color6
